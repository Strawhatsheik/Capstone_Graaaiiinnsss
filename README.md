# Capstone Grainsssss
## My zombie cow game.
![image](https://github.com/user-attachments/assets/d2dd5f38-aac2-4f19-8fb2-d27ec453a795)

This is a game level demo I made in Unreal Engine 4 with C++ for GAM-312 Gameplay Systems Development in March and April of 2021. We were required to produce a game but in the beginning parts of the class we had to complete certain tutorials, such as a light that turns on, a health item, a specific HUD, and other random assignments. I needed to use most of these elements in a cohesive conglomerate or waste my earlier work. Being a zombie game buff I decided I wanted to make a zombie game, and as we made our own projectile and ammo systems it seemed to lend itself towards a first person shooter.

During the AI segment of the course where we programmed a pawn to move using Unreal’s built in AI tools of a Behavior Tree, Blackboard, and a Navmesh, I practiced the lessons using a cow skeletal mesh. It came with a pack of farm animals from the Unreal Marketplace, and had animations making it ideal for a moving character. After much trial and error, I got the cow to idle and roam with the proper animations. Being my first AI character, learning to properly animate and move the cow was a much more extensive and involved process than I anticipated, and in completion I was so proud that I showed it to my sister. She recommended I use zombie cows and their goals would be “graaaainnnns.” I was so tickled with the idea that I started working towards my game and kept her pun as the name.

This project proved difficult and time consuming as the course used an outdated version of Unreal Engine and many of the tutorials had typos or clashed with each other. The AI work that was done with the Unreal tools (Blackboard and Behavior trees) never functioned one hundred percent. The animal would never attack, although it would patrol and idle. In the end, I utilized C++ for the zombie cow’s AI, giving it states of idle, roam, attack, and death. Each state has a corresponding animation. I used a debugger line to ensure it was entering each state correctly. For instance “I’m going to idle now” when it idled, or “I’m going back to looking for graaaiiinnsss” when it roamed, etc. Finally, all states were working in conjunction with the correct animation, except for one thing, when the cow was attacked by the player no damage was registered and its health was never depleted, which means it never entered the ‘dead’ state.

Obviously, the cow needed to attack and damage the player and vice versa. It took a lot of debugging time and study to solve this issue. By taking the code apart and comparing it with other functioning code, I found that the damage was being passed to the ‘damage’ function, but the function itself was not tied to anything. It wasn’t attached to a collision point and so was never properly called. By attaching it to the trigger box around the cow’s head, which was also used to damage the player, I thought I had resolved the issue but the cow still seemed to never die! By using another debugging line on the function, I noticed even when the player’s projectile passed through the trigger box, the function was never called. As mentioned above, this class had us creating our own projectile in C++, however the custom projectile did not have collision code in it for box collision. 

By placing the damage call event in the projectile and the damage receive event in the cow’s trigger box I finally enabled the cow to take hits and eventually enter the ‘dead’ state. Then I was able to tweak some other minor issues, such as the cow walking a little over the grass instead of on it, and not looking very ‘zombie like.’
The hardest challenge in refining this program was finding out why the code wasn’t working. This difficulty was compounded by a lot of extraneous code, or even in some cases double classes, such as with the projectile. This was caused by the amount of tutorials and practice runs done in the program during the class that had never been cleaned up. Also because the program was put together over the course of the module with different tutorials from different sources, they did not all mesh. One of the reasons damage worked in one case (such as the hazard object) and not in the case of my zombie cow was because one used the built in ‘applyDamage’ method in Unreal, and the other created its own damage sender/receiver.

The program is still in progress, being only a level demo at this time, but I have plans to make Graaaainnnns a complete game. The zombie cows will also have an ‘eat’ state, where they will attack the player’s grain (static mesh haystacks). Currently they wander to random board locations, idle, and will attack the player if they come within the cow’s sight range. When attacking, they speed up and their animation changes again. They only stop if killed or the player stays out of their sight range long enough. In the game’s current state, the player can take damage from the zombie cows and environmental items such as fire. They can heal by picking up apples, and their ammo replenishes over time. The zombie cows can only be hurt if shot in the head but do take damage and die if enough successful shots land. The player has a health and ammo bar and the screen flashes red when they take damage.

I created this game almost solely with Unreal Engine tools and C++. It is important to be able to use ‘straight code’ and enable it to work with Unreal Engine. Though Unreal Engine is a powerful tool, and has its own Blueprints scripting system, coding a game in C++ is more efficient for a processor. Working on this I furthered my understanding of object oriented programming, as well as AI, 3D movement and animation, game physics and logic, ability to work with static meshes and packages from the Unreal Marketplace, and HUD implementation along with UI/UX work.

Check out the details on my Behance! https://www.behance.net/gallery/129018663/GRAAAAIINNNNSSSS


